# 集群管理与权限设计文档

## 1. 背景与目标 (Context & Goals)

### 背景
CodeYun 系统支持管理多台设备（Cluster Nodes）。用户可以在一个统一的前端界面（Dashboard）上查看和控制不同物理机上的任务（Task）和进程。

### 目标
-   **去中心化/弱中心化**：不依赖单一的中心服务器转发流量，避免单点瓶颈。
-   **高性能**：前端直接与目标设备通信，延迟最低。
-   **权限安全**：确保跨设备操作经过严格认证，但又足够灵活以支持设备 ID 变更或数据导入场景。
-   **正交性**：权限逻辑、通信逻辑、业务逻辑应尽可能解耦。

## 2. 总体设计 (High-Level Design)

### 架构模式：前端直连 (Frontend Direct Connection)

系统采用 **“前端直连、Token 互信”** 的架构模式。

```mermaid
graph TD
    User[用户浏览器] -->|1. 获取设备列表 & Token| LocalBackend[本机后端 (Device A)]
    User -->|2. 直连请求 (携带 Token)| RemoteDevice[远程设备 (Device B)]
    
    subgraph Device A
        LocalBackend --> DB_A[本地数据库]
    end
    
    subgraph Device B
        RemoteDevice --> DB_B[远程数据库]
        RemoteDevice --> TaskExecutor[任务执行器]
    end
```

### 核心模块正交性分析

1.  **用户设备管理 (UserDevice Management)**
    *   **职责**：仅负责存储用户的设备列表和对应的访问凭证 (Token)。
    *   **正交性**：它不关心 Token 如何生成，也不关心远程设备的状态。它只是一个“通讯录”。
    *   **存储位置**：`UserDevice` 表（通常在用户登录的主节点数据库中）。

2.  **任务执行与管理 (Task Execution & Management)**
    *   **职责**：负责本机任务的 CRUD、进程监控、日志流。
    *   **正交性**：它完全不知道“集群”的存在。它只认“持有有效 Token 的请求”。只要请求通过了身份验证，就视为合法操作，无论请求来自本机前端还是远程前端。
    *   **存储位置**：`Task` 表（分布在每个设备的本地数据库中）。

3.  **前端客户端 (Frontend Client)**
    *   **职责**：根据当前选中的设备，动态切换 API `baseURL` 和 `Authorization Header`。
    *   **正交性**：前端逻辑不依赖后端转发。它是一个智能客户端，直接与目标服务器通话。

## 3. 详细设计 (Detailed Design)

### 3.1 通信模型 (Communication Model)

*   **传统模式 (Proxy)**：用户 -> 本机后端 -> 远程后端。
    *   *缺点*：本机后端成为瓶颈；代码复杂度高（需处理转发、WebSocket 隧道）；单点故障风险。
*   **当前模式 (Direct)**：用户 -> 远程后端。
    *   *优点*：利用浏览器直接并发访问能力；后端无状态化；速度最快。
    *   *要求*：远程设备需开启 CORS（允许跨域）；用户网络需能直连远程 IP。

### 3.2 权限与认证逻辑 (Authentication & Authorization)

#### 认证 (Who are you?)
每个设备在初始化时生成唯一的 `Master Token` (存储在 `config.json` 或 DB 中)。
任何请求只要在 Header 中携带此 Token：
```http
Authorization: Bearer <Device-Master-Token>
```
即被视为“超级管理员”或“设备持有者”访问。

#### 授权 (What can you do?)
在 `backend/api/task_manager.py` 中，权限检查逻辑遵循 **“持有 Token 即拥有所有权”** 的原则。

*   **旧逻辑（已废弃）**：严格检查 `Task.device_id == Current_Device_System_ID`。
    *   *问题*：当设备重置 System ID 或导入旧数据时，会导致任务无法操作（403 Forbidden），破坏了可用性。
*   **新逻辑（当前设计）**：
    *   只要通过了 `verify_api_token`（即持有有效 Token），就被允许操作该设备数据库中的**任何**任务。
    *   **理由**：物理设备是权限的边界。如果你能登录这台设备（持有 Token），你理应能管理这台设备上的所有数据。这解耦了“逻辑 ID”与“物理权限”。

### 3.3 数据流 (Data Flow)

1.  **添加设备**：
    *   用户输入远程设备的 URL 和 Token。
    *   前端调用本机后端 `/api/devices/add`。
    *   本机后端验证连接（Ping），验证通过后将 URL 和 Token 存入 `UserDevice` 表。

2.  **操作远程任务**：
    *   用户在前端切换到“设备 B”。
    *   前端从 Store 获取设备 B 的 URL 和 Token。
    *   前端创建 Axios 实例：`baseURL = Device_B_URL`。
    *   前端发起请求：`POST /api/task/create`。
    *   设备 B 后端接收请求 -> 验证 Token -> 创建任务写入 B 的数据库 -> 启动进程。

## 4. 设计优势 (Why this design?)

1.  **极简后端 (Backend Simplicity)**
    后端不需要编写复杂的“反向代理”或“集群同步”代码。每个后端实例都是独立的、无状态的（相对于集群而言）。集群的“状态”仅存在于用户的前端视图中。

2.  **容错性 (Fault Tolerance)**
    如果设备 A 宕机，不影响用户通过浏览器直接操作设备 B。集群没有“主节点”依赖。

3.  **高性能 (Performance)**
    日志流 (WebSocket) 直接从源头推送到浏览器，不经过中间跳板，延迟极低，带宽利用率高。

4.  **解耦 (Decoupling)**
    *   **ID 解耦**：任务管理不再强绑定于易变的 `System ID`，而是绑定于物理访问权限（Token）。
    *   **网络解耦**：内网穿透、VPN 等网络配置由用户网络环境决定，软件层不假设网络拓扑。

## 5. 注意事项与未来规划

*   **安全性**：Token 具有极高权限，泄露等同于 Root 权限。未来可考虑引入“只读 Token”或基于角色的细粒度权限 (RBAC)。
*   **网络限制**：纯直连模式要求浏览器能访问所有节点。如果在复杂网络环境（如云服务器+内网机器），未来可能需要可选的“中继模式 (Relay Mode)”作为补充。
